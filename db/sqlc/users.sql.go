// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.19.1
// source: users.sql

package db

import (
	"context"
	"database/sql"
)

const createUser = `-- name: CreateUser :one
INSERT INTO users (
        username,
        email,
        photo,
        password,
        last_name,
        first_name,
        auth_source,
        is_active
) VALUES
      ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, username, email, verified_email, photo, password, first_name, last_name, is_staff, is_active, is_superuser, is_deleted, auth_source, update_at, date_joined
`

type CreateUserParams struct {
	Username   string         `json:"username"`
	Email      string         `json:"email"`
	Photo      sql.NullString `json:"photo"`
	Password   string         `json:"password"`
	LastName   sql.NullString `json:"last_name"`
	FirstName  sql.NullString `json:"first_name"`
	AuthSource string         `json:"auth_source"`
	IsActive   sql.NullBool   `json:"is_active"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.queryRow(ctx, q.createUserStmt, createUser,
		arg.Username,
		arg.Email,
		arg.Photo,
		arg.Password,
		arg.LastName,
		arg.FirstName,
		arg.AuthSource,
		arg.IsActive,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.VerifiedEmail,
		&i.Photo,
		&i.Password,
		&i.FirstName,
		&i.LastName,
		&i.IsStaff,
		&i.IsActive,
		&i.IsSuperuser,
		&i.IsDeleted,
		&i.AuthSource,
		&i.UpdateAt,
		&i.DateJoined,
	)
	return i, err
}

const createUserAddress = `-- name: CreateUserAddress :one
INSERT INTO address(
    user_id,
    city,
    street,
    postal_code
)VALUES ($1,$2,$3,$4)
RETURNING id, user_id, city, street, postal_code
`

type CreateUserAddressParams struct {
	UserID     int32          `json:"user_id"`
	City       string         `json:"city"`
	Street     sql.NullString `json:"street"`
	PostalCode sql.NullInt64  `json:"postal_code"`
}

func (q *Queries) CreateUserAddress(ctx context.Context, arg CreateUserAddressParams) (Address, error) {
	row := q.queryRow(ctx, q.createUserAddressStmt, createUserAddress,
		arg.UserID,
		arg.City,
		arg.Street,
		arg.PostalCode,
	)
	var i Address
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.City,
		&i.Street,
		&i.PostalCode,
	)
	return i, err
}

const createUserPhone = `-- name: CreateUserPhone :one
INSERT INTO phones (
    user_id,
    number,
    country_code
) VALUES ($1, $2, $3)
RETURNING id, user_id, number, country_code, verified, create_at
`

type CreateUserPhoneParams struct {
	UserID      int32  `json:"user_id"`
	Number      int64  `json:"number"`
	CountryCode string `json:"country_code"`
}

func (q *Queries) CreateUserPhone(ctx context.Context, arg CreateUserPhoneParams) (Phone, error) {
	row := q.queryRow(ctx, q.createUserPhoneStmt, createUserPhone, arg.UserID, arg.Number, arg.CountryCode)
	var i Phone
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Number,
		&i.CountryCode,
		&i.Verified,
		&i.CreateAt,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, username, email, verified_email, photo, password, first_name, last_name, is_staff, is_active, is_superuser, is_deleted, auth_source, update_at, date_joined FROM users
WHERE email = $1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.queryRow(ctx, q.getUserByEmailStmt, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.VerifiedEmail,
		&i.Photo,
		&i.Password,
		&i.FirstName,
		&i.LastName,
		&i.IsStaff,
		&i.IsActive,
		&i.IsSuperuser,
		&i.IsDeleted,
		&i.AuthSource,
		&i.UpdateAt,
		&i.DateJoined,
	)
	return i, err
}

const getUserById = `-- name: GetUserById :one
SELECT id, username, email, verified_email, photo, password, first_name, last_name, is_staff, is_active, is_superuser, is_deleted, auth_source, update_at, date_joined FROM users
WHERE id = $1
`

func (q *Queries) GetUserById(ctx context.Context, id int32) (User, error) {
	row := q.queryRow(ctx, q.getUserByIdStmt, getUserById, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.VerifiedEmail,
		&i.Photo,
		&i.Password,
		&i.FirstName,
		&i.LastName,
		&i.IsStaff,
		&i.IsActive,
		&i.IsSuperuser,
		&i.IsDeleted,
		&i.AuthSource,
		&i.UpdateAt,
		&i.DateJoined,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT id, username, email, verified_email, photo, password, first_name, last_name, is_staff, is_active, is_superuser, is_deleted, auth_source, update_at, date_joined FROM users
WHERE username = $1
`

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (User, error) {
	row := q.queryRow(ctx, q.getUserByUsernameStmt, getUserByUsername, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.VerifiedEmail,
		&i.Photo,
		&i.Password,
		&i.FirstName,
		&i.LastName,
		&i.IsStaff,
		&i.IsActive,
		&i.IsSuperuser,
		&i.IsDeleted,
		&i.AuthSource,
		&i.UpdateAt,
		&i.DateJoined,
	)
	return i, err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users
SET
    username = COALESCE($1, username),
    email = COALESCE($2, email),
    photo = COALESCE($3, photo),
    first_name = COALESCE($4, first_name),
    last_name = COALESCE($5, last_name)
WHERE id = $6
RETURNING id, username, email, verified_email, photo, password, first_name, last_name, is_staff, is_active, is_superuser, is_deleted, auth_source, update_at, date_joined
`

type UpdateUserParams struct {
	Username  sql.NullString `json:"username"`
	Email     sql.NullString `json:"email"`
	Photo     sql.NullString `json:"photo"`
	FirstName sql.NullString `json:"first_name"`
	LastName  sql.NullString `json:"last_name"`
	ID        int32          `json:"id"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
	row := q.queryRow(ctx, q.updateUserStmt, updateUser,
		arg.Username,
		arg.Email,
		arg.Photo,
		arg.FirstName,
		arg.LastName,
		arg.ID,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.VerifiedEmail,
		&i.Photo,
		&i.Password,
		&i.FirstName,
		&i.LastName,
		&i.IsStaff,
		&i.IsActive,
		&i.IsSuperuser,
		&i.IsDeleted,
		&i.AuthSource,
		&i.UpdateAt,
		&i.DateJoined,
	)
	return i, err
}

const updateUserAddress = `-- name: UpdateUserAddress :one
UPDATE address
SET
    city = COALESCE($1, city),
    street = COALESCE($2, street),
    postal_code = COALESCE($3, postal_code)
WHERE user_id = $4
RETURNING id, user_id, city, street, postal_code
`

type UpdateUserAddressParams struct {
	City       sql.NullString `json:"city"`
	Street     sql.NullString `json:"street"`
	PostalCode sql.NullInt64  `json:"postal_code"`
	UserID     int32          `json:"user_id"`
}

func (q *Queries) UpdateUserAddress(ctx context.Context, arg UpdateUserAddressParams) (Address, error) {
	row := q.queryRow(ctx, q.updateUserAddressStmt, updateUserAddress,
		arg.City,
		arg.Street,
		arg.PostalCode,
		arg.UserID,
	)
	var i Address
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.City,
		&i.Street,
		&i.PostalCode,
	)
	return i, err
}

const updateUserPhone = `-- name: UpdateUserPhone :one
UPDATE phones
SET
    number = COALESCE($1, number),
    country_code = COALESCE($2, country_code)
WHERE user_id = $3 OR number = $4
RETURNING id, user_id, number, country_code, verified, create_at
`

type UpdateUserPhoneParams struct {
	Number      sql.NullInt64  `json:"number"`
	CountryCode sql.NullString `json:"country_code"`
	UserID      int32          `json:"user_id"`
	OldNumber   int64          `json:"old_number"`
}

func (q *Queries) UpdateUserPhone(ctx context.Context, arg UpdateUserPhoneParams) (Phone, error) {
	row := q.queryRow(ctx, q.updateUserPhoneStmt, updateUserPhone,
		arg.Number,
		arg.CountryCode,
		arg.UserID,
		arg.OldNumber,
	)
	var i Phone
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Number,
		&i.CountryCode,
		&i.Verified,
		&i.CreateAt,
	)
	return i, err
}
